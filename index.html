<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Junior High Quiz Battle</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        body { font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif; margin: 0; background: #f0f2f5; color: #333; overflow: hidden; touch-action: none; }
        .hidden { display: none !important; }
        .full-screen { position: absolute; top:0; left:0; width: 100vw; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        
        /* --- HOST SCREEN --- */
        #host-view { background: #fff; width: 100%; height: 100%; text-align: center; }
        header { padding: 20px; background: #2c3e50; color: white; width: 100%; box-sizing: border-box; display: flex; justify-content: space-between; align-items: center; }
        
        #question-card { margin-top: 40px; width: 80%; max-width: 800px; padding: 40px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); border-radius: 15px; background: white; display: inline-block; }
        .subject-badge { background: #3498db; color: white; padding: 5px 15px; border-radius: 20px; font-size: 14px; display: inline-block; margin-bottom: 15px; }
        .q-text { font-size: 36px; font-weight: bold; margin-bottom: 30px; line-height: 1.4; }
        
        /* Results / Answers Display */
        #answers-area { margin-top: 30px; display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; width: 90%; }
        .ans-card { background: #ecf0f1; padding: 10px; border-radius: 8px; min-width: 100px; text-align: center; border: 2px solid transparent; }
        .ans-card.correct { border-color: #27ae60; background: #e8f8f5; }
        .ans-card img { max-width: 150px; background: white; border: 1px solid #ccc; }
        
        /* Lobby */
        #lobby { z-index: 100; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        
        /* --- CONTROLLER (CLIENT) --- */
        #client-view { background: #222; color: white; padding: 20px; box-sizing: border-box; }
        
        /* Input Modes */
        .input-mode { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        
        /* Choice Buttons */
        .grid-btns { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; width: 100%; height: 60%; }
        .c-btn { border: none; border-radius: 12px; font-size: 24px; font-weight: bold; color: white; box-shadow: 0 4px 0 rgba(0,0,0,0.2); transition: 0.1s; }
        .c-btn:active { transform: translateY(4px); box-shadow: none; }
        .btn-0 { background: #e74c3c; } .btn-1 { background: #3498db; }
        .btn-2 { background: #f1c40f; color: #333; } .btn-3 { background: #2ecc71; }
        
        /* Text Input */
        #text-input { font-size: 24px; padding: 15px; width: 80%; border-radius: 8px; border: none; margin-bottom: 20px; text-align: center; }
        .submit-btn { background: #2ecc71; color: white; border: none; padding: 15px 40px; font-size: 20px; border-radius: 30px; font-weight: bold; }
        
        /* Handwriting Canvas */
        #draw-area { background: white; border-radius: 10px; touch-action: none; cursor: crosshair; margin-bottom: 20px; }
        .tools { display: flex; gap: 10px; }
        .tool-btn { padding: 10px 20px; border-radius: 5px; border: none; font-weight: bold; cursor: pointer; }
        
        #waiting-msg { font-size: 24px; color: #aaa; text-align: center; }

    </style>
</head>
<body>

    <div id="lobby" class="full-screen hidden">
        <h1>教室クイズサーバー</h1>
        <div id="qrcode" style="background: white; padding: 15px; border-radius: 10px; margin: 20px;"></div>
        <p>スマホでQRを読み込んで参加してください</p>
        <div id="player-count">参加者: 0人</div>
        <button onclick="startQuiz()" style="margin-top:20px; padding: 15px 30px; font-size:20px; cursor:pointer;">クイズ開始</button>
    </div>

    <div id="host-view" class="full-screen hidden">
        <header>
            <div id="room-id-disp">ID: ---</div>
            <div id="timer">--</div>
        </header>
        
        <div id="question-card">
            <span class="subject-badge" id="h-subject">教科</span>
            <div class="q-text" id="h-question">問題文...</div>
            <div id="h-info" style="color:#666; font-size:18px;"></div>
        </div>

        <div id="answers-area">
            </div>

        <div style="position: absolute; bottom: 30px;">
            <button id="next-btn" onclick="nextPhase()" class="submit-btn" style="background:#34495e;">正解を表示</button>
        </div>
    </div>

    <div id="client-view" class="full-screen hidden">
        <div id="waiting-msg">待機中...</div>

        <div id="mode-choice" class="input-mode hidden">
            <div class="grid-btns">
                <button class="c-btn btn-0" onclick="sendChoice(0)">A</button>
                <button class="c-btn btn-1" onclick="sendChoice(1)">B</button>
                <button class="c-btn btn-2" onclick="sendChoice(2)">C</button>
                <button class="c-btn btn-3" onclick="sendChoice(3)">D</button>
            </div>
        </div>

        <div id="mode-text" class="input-mode hidden">
            <p>答えを入力してください</p>
            <input type="text" id="text-input" placeholder="回答を入力...">
            <button class="submit-btn" onclick="sendText()">送信</button>
        </div>

        <div id="mode-draw" class="input-mode hidden">
            <p>枠の中に書いてください</p>
            <canvas id="draw-area" width="300" height="300"></canvas>
            <div class="tools">
                <button class="tool-btn" onclick="clearCanvas()" style="background:#e74c3c; color:white;">消す</button>
                <button class="tool-btn" onclick="sendDraw()" style="background:#2ecc71; color:white;">送信</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
        import { getDatabase, ref, update, onValue, onDisconnect, remove } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-database.js";

        // --- JSON DATA (全教科サンプル) ---
        // type: 'choice' | 'text' | 'draw'
        const QUIZ_DATA = [
            {
                subject: "社会・歴史",
                type: "choice",
                q: "1603年に江戸幕府を開いた人物は誰？",
                options: ["織田信長", "豊臣秀吉", "徳川家康", "足利尊氏"],
                ans: "徳川家康" // 正解判定用（選択肢の文字と一致させる）
            },
            {
                subject: "数学",
                type: "text",
                q: "次の方程式を解きなさい。<br>3x + 5 = 14",
                ans: "3" // 部分一致などで判定
            },
            {
                subject: "国語・漢字",
                type: "draw",
                q: "「カンペキ」を漢字で書きなさい。",
                ans: "完璧" // 手書きはホストが目視確認、または正解文字を表示のみ
            },
            {
                subject: "理科",
                type: "choice",
                q: "植物が光のエネルギーを使って養分を作る働きを何という？",
                options: ["呼吸", "光合成", "蒸散", "消化"],
                ans: "光合成"
            },
            {
                subject: "英語",
                type: "text",
                q: "「図書館」を英語で綴りなさい。（すべて小文字で）",
                ans: "library"
            },
            {
                subject: "地理",
                type: "draw",
                q: "日本の「北海道」の形を描きなさい。",
                ans: "(図形判定なし)"
            }
        ];

        // --- FIREBASE SETUP ---
        const firebaseConfig = {
            apiKey: "AIzaSyDbZzTMvUkG2LXIGY4ux0KBTmnAdqP236s", // 公開用デモキー
            authDomain: "game-4f2d9.firebaseapp.com",
            databaseURL: "https://game-4f2d9-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "game-4f2d9"
        };
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // --- LOGIC ---
        const params = new URLSearchParams(window.location.search);
        let role = params.get('role');
        let roomId = params.get('room');
        const myId = Math.random().toString(36).substr(2, 6);
        
        // Host Variables
        let currentQIndex = 0;
        let qStatus = 'lobby'; // lobby, answering, result

        // Client Canvas
        let canvas, ctx, isDrawing = false;

        // --- INITIALIZATION ---
        if (!role) {
            // No role specified, create host
            roomId = Math.random().toString(36).substring(2, 6).toUpperCase();
            window.location.replace(`?role=host&room=${roomId}`);
        }

        if (role === 'host') {
            document.getElementById('room-id-disp').innerText = `ID: ${roomId}`;
            document.getElementById('lobby').classList.remove('hidden');

            // QR Code
            const url = `${window.location.origin}${window.location.pathname}?role=client&room=${roomId}`;
            new QRCode(document.getElementById("qrcode"), { text: url, width: 150, height: 150 });

            // Listen for players
            onValue(ref(db, `rooms/${roomId}/players`), (snap) => {
                const players = snap.val() || {};
                document.getElementById('player-count').innerText = `参加者: ${Object.keys(players).length}人`;
                renderHostAnswers(players);
            });

            window.startQuiz = () => {
                currentQIndex = 0;
                document.getElementById('lobby').classList.add('hidden');
                document.getElementById('host-view').classList.remove('hidden');
                loadQuestion();
            };

            window.nextPhase = () => {
                if (qStatus === 'answering') {
                    // Show Result
                    qStatus = 'result';
                    document.getElementById('next-btn').innerText = "次の問題へ";
                    
                    const q = QUIZ_DATA[currentQIndex];
                    document.getElementById('h-info').innerHTML = `正解: <span style="color:#e74c3c; font-weight:bold; font-size:32px;">${q.ans}</span>`;
                    
                    // Reveal/Grade Logic in visual
                    update(ref(db, `rooms/${roomId}/state`), { phase: 'result', correct: q.ans });

                } else if (qStatus === 'result') {
                    // Next Question
                    currentQIndex++;
                    if (currentQIndex >= QUIZ_DATA.length) {
                        alert("全問終了！お疲れ様でした。");
                        currentQIndex = 0; // Loop or End
                    }
                    loadQuestion();
                }
            };
        } else {
            // Client Setup
            document.getElementById('client-view').classList.remove('hidden');
            const myRef = ref(db, `rooms/${roomId}/players/${myId}`);
            onDisconnect(myRef).remove();
            update(myRef, { name: 'Player', score: 0 });

            // Listen to Game State
            onValue(ref(db, `rooms/${roomId}/state`), (snap) => {
                const state = snap.val();
                if (!state) return;

                if (state.phase === 'question') {
                    setupClientInput(state.qData);
                } else if (state.phase === 'result') {
                    document.getElementById('waiting-msg').innerText = "正解発表中...";
                    document.getElementById('waiting-msg').classList.remove('hidden');
                    hideAllInputs();
                }
            });

            initCanvas();
        }

        // --- HOST FUNCTIONS ---
        function loadQuestion() {
            qStatus = 'answering';
            const q = QUIZ_DATA[currentQIndex];
            
            // Display Host
            document.getElementById('h-subject').innerText = q.subject;
            document.getElementById('h-question').innerHTML = q.q;
            document.getElementById('h-info').innerText = "回答受付中...";
            document.getElementById('next-btn').innerText = "正解を表示";
            document.getElementById('answers-area').innerHTML = ''; // Clear previous answers

            // Reset Player Answers in DB
            // Note: In a real app, we might use cloud functions or iterate updates. 
            // Here we rely on clients overwriting their own answer on new Q, 
            // but ideally host clears them. Let's just broadcast new Q.
            
            // Send to Clients
            // We verify choices options to send to client
            let clientQData = { type: q.type, qText: q.q };
            if (q.type === 'choice') clientQData.options = q.options;

            update(ref(db, `rooms/${roomId}/state`), { 
                phase: 'question', 
                qData: clientQData,
                timestamp: Date.now()
            });
        }

        function renderHostAnswers(players) {
            if (role !== 'host') return;
            const area = document.getElementById('answers-area');
            area.innerHTML = '';
            
            const currentAns = QUIZ_DATA[currentQIndex]?.ans;

            Object.entries(players).forEach(([id, p]) => {
                if (!p.answer) return; // Skip if no answer yet

                const card = document.createElement('div');
                card.className = 'ans-card';
                
                let content = '';
                if (p.answer.type === 'image') {
                    content = `<img src="${p.answer.val}">`;
                } else {
                    content = `<div style="font-size:24px; font-weight:bold;">${p.answer.val}</div>`;
                }
                
                // Simple Grading Visualization (only during Result phase)
                if (qStatus === 'result' && currentAns) {
                    // Check logic
                    let isCorrect = false;
                    if(QUIZ_DATA[currentQIndex].type === 'choice' || QUIZ_DATA[currentQIndex].type === 'text') {
                        if (p.answer.val == currentAns) isCorrect = true; // Loose equality
                    }
                    if (isCorrect) card.classList.add('correct');
                }

                card.innerHTML = `<div>${p.name || id.substr(0,3)}</div>${content}`;
                area.appendChild(card);
            });
        }

        // --- CLIENT FUNCTIONS ---
        function hideAllInputs() {
            document.querySelectorAll('.input-mode').forEach(el => el.classList.add('hidden'));
        }

        function setupClientInput(qData) {
            hideAllInputs();
            document.getElementById('waiting-msg').classList.add('hidden');

            if (qData.type === 'choice') {
                const el = document.getElementById('mode-choice');
                el.classList.remove('hidden');
                // Set button text
                qData.options.forEach((opt, i) => {
                    const btn = el.querySelector(`.btn-${i}`);
                    if(btn) btn.innerText = opt;
                });

            } else if (qData.type === 'text') {
                const el = document.getElementById('mode-text');
                el.classList.remove('hidden');
                document.getElementById('text-input').value = '';

            } else if (qData.type === 'draw') {
                const el = document.getElementById('mode-draw');
                el.classList.remove('hidden');
                clearCanvas();
            }
        }

        // --- CLIENT SEND ACTIONS ---
        window.sendChoice = (index) => {
            // Get option text locally or send index? 
            // Sending index is safer, but let's send text for display simplicity on Host
            // Need to get text from buttons.
            const btn = document.querySelector(`.btn-${index}`);
            const val = btn.innerText;
            submitAnswer(val, 'text');
            waitUI();
        };

        window.sendText = () => {
            const val = document.getElementById('text-input').value;
            if(!val) return;
            submitAnswer(val, 'text');
            waitUI();
        };

        window.sendDraw = () => {
            const dataUrl = canvas.toDataURL('image/png', 0.5); // Compress slightly
            submitAnswer(dataUrl, 'image');
            waitUI();
        };

        function submitAnswer(val, type) {
            update(ref(db, `rooms/${roomId}/players/${myId}/answer`), {
                type: type,
                val: val,
                timestamp: Date.now()
            });
        }

        function waitUI() {
            hideAllInputs();
            document.getElementById('waiting-msg').innerText = "回答を送信しました！";
            document.getElementById('waiting-msg').classList.remove('hidden');
        }

        // --- CANVAS LOGIC ---
        function initCanvas() {
            canvas = document.getElementById('draw-area');
            ctx = canvas.getContext('2d');
            
            // Adjust for high DPI
            // For simple demo, fixed size 300x300 is used in CSS
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#000';

            const startDraw = (e) => {
                isDrawing = true;
                ctx.beginPath();
                const rect = canvas.getBoundingClientRect();
                const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
                const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
                ctx.moveTo(x, y);
                e.preventDefault();
            };

            const moveDraw = (e) => {
                if (!isDrawing) return;
                const rect = canvas.getBoundingClientRect();
                const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
                const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
                ctx.lineTo(x, y);
                ctx.stroke();
                e.preventDefault();
            };

            const endDraw = () => { isDrawing = false; };

            canvas.addEventListener('mousedown', startDraw);
            canvas.addEventListener('mousemove', moveDraw);
            canvas.addEventListener('mouseup', endDraw);
            canvas.addEventListener('touchstart', startDraw, {passive: false});
            canvas.addEventListener('touchmove', moveDraw, {passive: false});
            canvas.addEventListener('touchend', endDraw);
        }

        window.clearCanvas = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        };

    </script>
</body>
</html>
